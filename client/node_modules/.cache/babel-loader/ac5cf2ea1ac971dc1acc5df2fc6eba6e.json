{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Adrian/Documents/web102/web102_final/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/Adrian/Documents/web102/web102_final/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Adrian/Documents/web102/web102_final/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthPKCEGrantCodeExchangeError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthApiError, isAuthError } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid, retryable, sleep, generatePKCEVerifier, generatePKCEChallenge } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nvar DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n  flowType: 'implicit'\n};\n/** Current session will be checked for refresh at this interval. */\n\nvar AUTO_REFRESH_TICK_DURATION = 10 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\n\nvar AUTO_REFRESH_TICK_THRESHOLD = 3;\n\nvar GoTrueClient = /*#__PURE__*/function () {\n  /**\n   * Create a new client for use in the browser.\n   */\n  function GoTrueClient(options) {\n    var _this = this;\n\n    _classCallCheck(this, GoTrueClient);\n\n    var _a;\n\n    this.stateChangeEmitters = new Map();\n    this.autoRefreshTicker = null;\n    this.visibilityChangedCallback = null;\n    this.refreshingDeferred = null;\n    /**\n     * Keeps track of the async client initialization.\n     * When null or not yet resolved the auth state is `unknown`\n     * Once resolved the the auth state is known and it's save to call any further client methods.\n     * Keep extra care to never reject or throw uncaught errors\n     */\n\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    /**\n     * Used to broadcast state change events to other tabs listening.\n     */\n\n    this.broadcastChannel = null;\n    var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || localStorageAdapter;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.flowType = settings.flowType;\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n    };\n\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n      try {\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n      } catch (e) {\n        console.error('Failed to create a new BroadcastChannel, multi-tab state changes will not be available', e);\n      }\n\n      (_a = this.broadcastChannel) === null || _a === void 0 ? void 0 : _a.addEventListener('message', function (event) {\n        _this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n\n      });\n    }\n\n    this.initialize();\n  }\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n\n\n  _createClass(GoTrueClient, [{\n    key: \"initialize\",\n    value: function initialize() {\n      if (!this.initializePromise) {\n        this.initializePromise = this._initialize();\n      }\n\n      return this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */\n\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n\n        var isPKCEFlow, _yield$this$_getSessi, data, error, session, redirectType;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.initializePromise) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.initializePromise);\n\n              case 2:\n                _context.prev = 2;\n                _context.next = 5;\n                return this._isPKCEFlow();\n\n              case 5:\n                isPKCEFlow = _context.sent;\n\n                if (!(this.detectSessionInUrl && this._isImplicitGrantFlow() || isPKCEFlow)) {\n                  _context.next = 21;\n                  break;\n                }\n\n                _context.next = 9;\n                return this._getSessionFromUrl(isPKCEFlow);\n\n              case 9:\n                _yield$this$_getSessi = _context.sent;\n                data = _yield$this$_getSessi.data;\n                error = _yield$this$_getSessi.error;\n\n                if (!error) {\n                  _context.next = 16;\n                  break;\n                }\n\n                _context.next = 15;\n                return this._removeSession();\n\n              case 15:\n                return _context.abrupt(\"return\", {\n                  error: error\n                });\n\n              case 16:\n                session = data.session, redirectType = data.redirectType;\n                _context.next = 19;\n                return this._saveSession(session);\n\n              case 19:\n                setTimeout(function () {\n                  if (redirectType === 'recovery') {\n                    _this2._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n                  } else {\n                    _this2._notifyAllSubscribers('SIGNED_IN', session);\n                  }\n                }, 0);\n                return _context.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 21:\n                _context.next = 23;\n                return this._recoverAndRefresh();\n\n              case 23:\n                return _context.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 26:\n                _context.prev = 26;\n                _context.t0 = _context[\"catch\"](2);\n\n                if (!isAuthError(_context.t0)) {\n                  _context.next = 30;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  error: _context.t0\n                });\n\n              case 30:\n                return _context.abrupt(\"return\", {\n                  error: new AuthUnknownError('Unexpected error during initialization', _context.t0)\n                });\n\n              case 31:\n                _context.prev = 31;\n                _context.next = 34;\n                return this._handleVisibilityChange();\n\n              case 34:\n                return _context.finish(31);\n\n              case 35:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 26, 31, 35]]);\n      }));\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n\n  }, {\n    key: \"signUp\",\n    value: function signUp(credentials) {\n      var _a, _b, _c;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var res, email, password, options, codeChallenge, codeChallengeMethod, codeVerifier, phone, _password, _options, _res, data, error, session, user;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this._removeSession();\n\n              case 3:\n                if (!('email' in credentials)) {\n                  _context2.next = 20;\n                  break;\n                }\n\n                email = credentials.email, password = credentials.password, options = credentials.options;\n                codeChallenge = null;\n                codeChallengeMethod = null;\n\n                if (!(this.flowType === 'pkce')) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                codeVerifier = generatePKCEVerifier();\n                _context2.next = 11;\n                return setItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"), codeVerifier);\n\n              case 11:\n                _context2.next = 13;\n                return generatePKCEChallenge(codeVerifier);\n\n              case 13:\n                codeChallenge = _context2.sent;\n                codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n\n              case 15:\n                _context2.next = 17;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                  headers: this.headers,\n                  redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                  body: {\n                    email: email,\n                    password: password,\n                    data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    },\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 17:\n                res = _context2.sent;\n                _context2.next = 28;\n                break;\n\n              case 20:\n                if (!('phone' in credentials)) {\n                  _context2.next = 27;\n                  break;\n                }\n\n                phone = credentials.phone, _password = credentials.password, _options = credentials.options;\n                _context2.next = 24;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    password: _password,\n                    data: (_b = _options === null || _options === void 0 ? void 0 : _options.data) !== null && _b !== void 0 ? _b : {},\n                    channel: (_c = _options === null || _options === void 0 ? void 0 : _options.channel) !== null && _c !== void 0 ? _c : 'sms',\n                    gotrue_meta_security: {\n                      captcha_token: _options === null || _options === void 0 ? void 0 : _options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 24:\n                res = _context2.sent;\n                _context2.next = 28;\n                break;\n\n              case 27:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n\n              case 28:\n                _res = res, data = _res.data, error = _res.error;\n\n                if (!(error || !data)) {\n                  _context2.next = 31;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 31:\n                session = data.session;\n                user = data.user;\n\n                if (!data.session) {\n                  _context2.next = 37;\n                  break;\n                }\n\n                _context2.next = 36;\n                return this._saveSession(data.session);\n\n              case 36:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n\n              case 37:\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 40:\n                _context2.prev = 40;\n                _context2.t0 = _context2[\"catch\"](0);\n\n                if (!isAuthError(_context2.t0)) {\n                  _context2.next = 44;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context2.t0\n                });\n\n              case 44:\n                throw _context2.t0;\n\n              case 45:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 40]]);\n      }));\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */\n\n  }, {\n    key: \"signInWithPassword\",\n    value: function signInWithPassword(credentials) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var res, email, password, options, phone, _password2, _options2, _res2, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return this._removeSession();\n\n              case 3:\n                if (!('email' in credentials)) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                email = credentials.email, password = credentials.password, options = credentials.options;\n                _context3.next = 7;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                  headers: this.headers,\n                  body: {\n                    email: email,\n                    password: password,\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 7:\n                res = _context3.sent;\n                _context3.next = 18;\n                break;\n\n              case 10:\n                if (!('phone' in credentials)) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                phone = credentials.phone, _password2 = credentials.password, _options2 = credentials.options;\n                _context3.next = 14;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    password: _password2,\n                    gotrue_meta_security: {\n                      captcha_token: _options2 === null || _options2 === void 0 ? void 0 : _options2.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 14:\n                res = _context3.sent;\n                _context3.next = 18;\n                break;\n\n              case 17:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n\n              case 18:\n                _res2 = res, data = _res2.data, error = _res2.error;\n\n                if (!(error || !data)) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 21:\n                if (!data.session) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                _context3.next = 24;\n                return this._saveSession(data.session);\n\n              case 24:\n                this._notifyAllSubscribers('SIGNED_IN', data.session);\n\n              case 25:\n                return _context3.abrupt(\"return\", {\n                  data: data,\n                  error: error\n                });\n\n              case 28:\n                _context3.prev = 28;\n                _context3.t0 = _context3[\"catch\"](0);\n\n                if (!isAuthError(_context3.t0)) {\n                  _context3.next = 32;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context3.t0\n                });\n\n              case 32:\n                throw _context3.t0;\n\n              case 33:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 28]]);\n      }));\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     */\n\n  }, {\n    key: \"signInWithOAuth\",\n    value: function signInWithOAuth(credentials) {\n      var _a, _b, _c, _d;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._removeSession();\n\n              case 2:\n                _context4.next = 4;\n                return this._handleProviderSignIn(credentials.provider, {\n                  redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                  scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                  queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                  skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect\n                });\n\n              case 4:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     */\n\n  }, {\n    key: \"exchangeCodeForSession\",\n    value: function exchangeCodeForSession(authCode) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var codeVerifier, _yield$_request, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return getItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n\n              case 2:\n                codeVerifier = _context5.sent;\n                _context5.next = 5;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=pkce\"), {\n                  headers: this.headers,\n                  body: {\n                    auth_code: authCode,\n                    code_verifier: codeVerifier\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 5:\n                _yield$_request = _context5.sent;\n                data = _yield$_request.data;\n                error = _yield$_request.error;\n                _context5.next = 10;\n                return removeItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n\n              case 10:\n                if (!(error || !data)) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 12:\n                if (!data.session) {\n                  _context5.next = 16;\n                  break;\n                }\n\n                _context5.next = 15;\n                return this._saveSession(data.session);\n\n              case 15:\n                this._notifyAllSubscribers('SIGNED_IN', data.session);\n\n              case 16:\n                return _context5.abrupt(\"return\", {\n                  data: data,\n                  error: error\n                });\n\n              case 17:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\n     * Allows signing in with an ID token issued by certain supported providers.\n     * The ID token is verified for validity and a new session is established.\n     *\n     * @experimental\n     */\n\n  }, {\n    key: \"signInWithIdToken\",\n    value: function signInWithIdToken(credentials) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var options, provider, token, nonce, res, data, error;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this._removeSession();\n\n              case 2:\n                _context6.prev = 2;\n                options = credentials.options, provider = credentials.provider, token = credentials.token, nonce = credentials.nonce;\n                _context6.next = 6;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=id_token\"), {\n                  headers: this.headers,\n                  body: {\n                    provider: provider,\n                    id_token: token,\n                    nonce: nonce,\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 6:\n                res = _context6.sent;\n                data = res.data, error = res.error;\n\n                if (!(error || !data)) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 10:\n                if (!data.session) {\n                  _context6.next = 14;\n                  break;\n                }\n\n                _context6.next = 13;\n                return this._saveSession(data.session);\n\n              case 13:\n                this._notifyAllSubscribers('SIGNED_IN', data.session);\n\n              case 14:\n                return _context6.abrupt(\"return\", {\n                  data: data,\n                  error: error\n                });\n\n              case 17:\n                _context6.prev = 17;\n                _context6.t0 = _context6[\"catch\"](2);\n\n                if (!isAuthError(_context6.t0)) {\n                  _context6.next = 21;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context6.t0\n                });\n\n              case 21:\n                throw _context6.t0;\n\n              case 22:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[2, 17]]);\n      }));\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     *\n     * Do note that you will need to configure a Whatsapp sender on Twilio\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n     * channel is not supported on other providers\n     * at this time.\n     */\n\n  }, {\n    key: \"signInWithOtp\",\n    value: function signInWithOtp(credentials) {\n      var _a, _b, _c, _d, _e;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var email, options, codeChallenge, codeChallengeMethod, codeVerifier, _yield$_request2, error, phone, _options3, _yield$_request3, _error;\n\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                _context7.next = 3;\n                return this._removeSession();\n\n              case 3:\n                if (!('email' in credentials)) {\n                  _context7.next = 20;\n                  break;\n                }\n\n                email = credentials.email, options = credentials.options;\n                codeChallenge = null;\n                codeChallengeMethod = null;\n\n                if (!(this.flowType === 'pkce')) {\n                  _context7.next = 15;\n                  break;\n                }\n\n                codeVerifier = generatePKCEVerifier();\n                _context7.next = 11;\n                return setItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"), codeVerifier);\n\n              case 11:\n                _context7.next = 13;\n                return generatePKCEChallenge(codeVerifier);\n\n              case 13:\n                codeChallenge = _context7.sent;\n                codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n\n              case 15:\n                _context7.next = 17;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                  headers: this.headers,\n                  body: {\n                    email: email,\n                    data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                    create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    },\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod\n                  },\n                  redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n\n              case 17:\n                _yield$_request2 = _context7.sent;\n                error = _yield$_request2.error;\n                return _context7.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 20:\n                if (!('phone' in credentials)) {\n                  _context7.next = 27;\n                  break;\n                }\n\n                phone = credentials.phone, _options3 = credentials.options;\n                _context7.next = 24;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    data: (_c = _options3 === null || _options3 === void 0 ? void 0 : _options3.data) !== null && _c !== void 0 ? _c : {},\n                    create_user: (_d = _options3 === null || _options3 === void 0 ? void 0 : _options3.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                    gotrue_meta_security: {\n                      captcha_token: _options3 === null || _options3 === void 0 ? void 0 : _options3.captchaToken\n                    },\n                    channel: (_e = _options3 === null || _options3 === void 0 ? void 0 : _options3.channel) !== null && _e !== void 0 ? _e : 'sms'\n                  }\n                });\n\n              case 24:\n                _yield$_request3 = _context7.sent;\n                _error = _yield$_request3.error;\n                return _context7.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _error\n                });\n\n              case 27:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n\n              case 30:\n                _context7.prev = 30;\n                _context7.t0 = _context7[\"catch\"](0);\n\n                if (!isAuthError(_context7.t0)) {\n                  _context7.next = 34;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context7.t0\n                });\n\n              case 34:\n                throw _context7.t0;\n\n              case 35:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 30]]);\n      }));\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     */\n\n  }, {\n    key: \"verifyOtp\",\n    value: function verifyOtp(params) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _yield$_request4, data, error, session, user;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                _context8.next = 3;\n                return this._removeSession();\n\n              case 3:\n                _context8.next = 5;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/verify\"), {\n                  headers: this.headers,\n                  body: Object.assign(Object.assign({}, params), {\n                    gotrue_meta_security: {\n                      captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken\n                    }\n                  }),\n                  redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n                  xform: _sessionResponse\n                });\n\n              case 5:\n                _yield$_request4 = _context8.sent;\n                data = _yield$_request4.data;\n                error = _yield$_request4.error;\n\n                if (!error) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                throw error;\n\n              case 10:\n                if (data) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                throw new Error('An error occurred on token verification.');\n\n              case 12:\n                session = data.session;\n                user = data.user;\n\n                if (!(session === null || session === void 0 ? void 0 : session.access_token)) {\n                  _context8.next = 18;\n                  break;\n                }\n\n                _context8.next = 17;\n                return this._saveSession(session);\n\n              case 17:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n\n              case 18:\n                return _context8.abrupt(\"return\", {\n                  data: {\n                    user: user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 21:\n                _context8.prev = 21;\n                _context8.t0 = _context8[\"catch\"](0);\n\n                if (!isAuthError(_context8.t0)) {\n                  _context8.next = 25;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context8.t0\n                });\n\n              case 25:\n                throw _context8.t0;\n\n              case 26:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 21]]);\n      }));\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     */\n\n  }, {\n    key: \"signInWithSSO\",\n    value: function signInWithSSO(params) {\n      var _a, _b, _c;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                _context9.next = 3;\n                return this._removeSession();\n\n              case 3:\n                _context9.next = 5;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/sso\"), {\n                  body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {\n                    provider_id: params.providerId\n                  } : null), 'domain' in params ? {\n                    domain: params.domain\n                  } : null), {\n                    redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n                  }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n                    gotrue_meta_security: {\n                      captcha_token: params.options.captchaToken\n                    }\n                  } : null), {\n                    skip_http_redirect: true\n                  }),\n                  headers: this.headers,\n                  xform: _ssoResponse\n                });\n\n              case 5:\n                return _context9.abrupt(\"return\", _context9.sent);\n\n              case 8:\n                _context9.prev = 8;\n                _context9.t0 = _context9[\"catch\"](0);\n\n                if (!isAuthError(_context9.t0)) {\n                  _context9.next = 12;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", {\n                  data: null,\n                  error: _context9.t0\n                });\n\n              case 12:\n                throw _context9.t0;\n\n              case 13:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 8]]);\n      }));\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     */\n\n  }, {\n    key: \"getSession\",\n    value: function getSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var currentSession, maybeSession, hasExpired, _yield$this$_callRefr, session, error;\n\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.initializePromise;\n\n              case 2:\n                currentSession = null;\n\n                if (!this.persistSession) {\n                  _context10.next = 16;\n                  break;\n                }\n\n                _context10.next = 6;\n                return getItemAsync(this.storage, this.storageKey);\n\n              case 6:\n                maybeSession = _context10.sent;\n\n                if (!(maybeSession !== null)) {\n                  _context10.next = 14;\n                  break;\n                }\n\n                if (!this._isValidSession(maybeSession)) {\n                  _context10.next = 12;\n                  break;\n                }\n\n                currentSession = maybeSession;\n                _context10.next = 14;\n                break;\n\n              case 12:\n                _context10.next = 14;\n                return this._removeSession();\n\n              case 14:\n                _context10.next = 17;\n                break;\n\n              case 16:\n                currentSession = this.inMemorySession;\n\n              case 17:\n                if (currentSession) {\n                  _context10.next = 19;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    session: null\n                  },\n                  error: null\n                });\n\n              case 19:\n                hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;\n\n                if (hasExpired) {\n                  _context10.next = 22;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    session: currentSession\n                  },\n                  error: null\n                });\n\n              case 22:\n                _context10.next = 24;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 24:\n                _yield$this$_callRefr = _context10.sent;\n                session = _yield$this$_callRefr.session;\n                error = _yield$this$_callRefr.error;\n\n                if (!error) {\n                  _context10.next = 29;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 29:\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 30:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n    /**\n     * Gets the current user details if there is an existing session.\n     * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function getUser(jwt) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var _yield$this$getSessio, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.prev = 0;\n\n                if (jwt) {\n                  _context11.next = 10;\n                  break;\n                }\n\n                _context11.next = 4;\n                return this.getSession();\n\n              case 4:\n                _yield$this$getSessio = _context11.sent;\n                data = _yield$this$getSessio.data;\n                error = _yield$this$getSessio.error;\n\n                if (!error) {\n                  _context11.next = 9;\n                  break;\n                }\n\n                throw error;\n\n              case 9:\n                // Default to Authorization header if there is no existing session\n                jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n\n              case 10:\n                _context11.next = 12;\n                return _request(this.fetch, 'GET', \"\".concat(this.url, \"/user\"), {\n                  headers: this.headers,\n                  jwt: jwt,\n                  xform: _userResponse\n                });\n\n              case 12:\n                return _context11.abrupt(\"return\", _context11.sent);\n\n              case 15:\n                _context11.prev = 15;\n                _context11.t0 = _context11[\"catch\"](0);\n\n                if (!isAuthError(_context11.t0)) {\n                  _context11.next = 19;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", {\n                  data: {\n                    user: null\n                  },\n                  error: _context11.t0\n                });\n\n              case 19:\n                throw _context11.t0;\n\n              case 20:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[0, 15]]);\n      }));\n    }\n    /**\n     * Updates user data for a logged in user.\n     */\n\n  }, {\n    key: \"updateUser\",\n    value: function updateUser(attributes) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var _yield$this$getSessio2, sessionData, sessionError, session, _yield$_request5, data, userError;\n\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n                _context12.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio2 = _context12.sent;\n                sessionData = _yield$this$getSessio2.data;\n                sessionError = _yield$this$getSessio2.error;\n\n                if (!sessionError) {\n                  _context12.next = 8;\n                  break;\n                }\n\n                throw sessionError;\n\n              case 8:\n                if (sessionData.session) {\n                  _context12.next = 10;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 10:\n                session = sessionData.session;\n                _context12.next = 13;\n                return _request(this.fetch, 'PUT', \"\".concat(this.url, \"/user\"), {\n                  headers: this.headers,\n                  redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                  body: attributes,\n                  jwt: session.access_token,\n                  xform: _userResponse\n                });\n\n              case 13:\n                _yield$_request5 = _context12.sent;\n                data = _yield$_request5.data;\n                userError = _yield$_request5.error;\n\n                if (!userError) {\n                  _context12.next = 18;\n                  break;\n                }\n\n                throw userError;\n\n              case 18:\n                session.user = data.user;\n                _context12.next = 21;\n                return this._saveSession(session);\n\n              case 21:\n                this._notifyAllSubscribers('USER_UPDATED', session);\n\n                return _context12.abrupt(\"return\", {\n                  data: {\n                    user: session.user\n                  },\n                  error: null\n                });\n\n              case 25:\n                _context12.prev = 25;\n                _context12.t0 = _context12[\"catch\"](0);\n\n                if (!isAuthError(_context12.t0)) {\n                  _context12.next = 29;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", {\n                  data: {\n                    user: null\n                  },\n                  error: _context12.t0\n                });\n\n              case 29:\n                throw _context12.t0;\n\n              case 30:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[0, 25]]);\n      }));\n    }\n    /**\n     * Decodes a JWT (without performing any validation).\n     */\n\n  }, {\n    key: \"_decodeJWT\",\n    value: function _decodeJWT(jwt) {\n      return decodeJWTPayload(jwt);\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */\n\n  }, {\n    key: \"setSession\",\n    value: function setSession(currentSession) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var timeNow, expiresAt, hasExpired, session, payload, _yield$this$_callRefr2, refreshedSession, error, _yield$this$getUser, data, _error2;\n\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.prev = 0;\n\n                if (!(!currentSession.access_token || !currentSession.refresh_token)) {\n                  _context13.next = 3;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 3:\n                timeNow = Date.now() / 1000;\n                expiresAt = timeNow;\n                hasExpired = true;\n                session = null;\n                payload = decodeJWTPayload(currentSession.access_token);\n\n                if (payload.exp) {\n                  expiresAt = payload.exp;\n                  hasExpired = expiresAt <= timeNow;\n                }\n\n                if (!hasExpired) {\n                  _context13.next = 22;\n                  break;\n                }\n\n                _context13.next = 12;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 12:\n                _yield$this$_callRefr2 = _context13.sent;\n                refreshedSession = _yield$this$_callRefr2.session;\n                error = _yield$this$_callRefr2.error;\n\n                if (!error) {\n                  _context13.next = 17;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 17:\n                if (refreshedSession) {\n                  _context13.next = 19;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: null\n                });\n\n              case 19:\n                session = refreshedSession;\n                _context13.next = 33;\n                break;\n\n              case 22:\n                _context13.next = 24;\n                return this.getUser(currentSession.access_token);\n\n              case 24:\n                _yield$this$getUser = _context13.sent;\n                data = _yield$this$getUser.data;\n                _error2 = _yield$this$getUser.error;\n\n                if (!_error2) {\n                  _context13.next = 29;\n                  break;\n                }\n\n                throw _error2;\n\n              case 29:\n                session = {\n                  access_token: currentSession.access_token,\n                  refresh_token: currentSession.refresh_token,\n                  user: data.user,\n                  token_type: 'bearer',\n                  expires_in: expiresAt - timeNow,\n                  expires_at: expiresAt\n                };\n                _context13.next = 32;\n                return this._saveSession(session);\n\n              case 32:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n\n              case 33:\n                return _context13.abrupt(\"return\", {\n                  data: {\n                    user: session.user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 36:\n                _context13.prev = 36;\n                _context13.t0 = _context13[\"catch\"](0);\n\n                if (!isAuthError(_context13.t0)) {\n                  _context13.next = 40;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    user: null\n                  },\n                  error: _context13.t0\n                });\n\n              case 40:\n                throw _context13.t0;\n\n              case 41:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[0, 36]]);\n      }));\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */\n\n  }, {\n    key: \"refreshSession\",\n    value: function refreshSession(currentSession) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var _yield$this$getSessio3, data, _error3, _yield$this$_callRefr3, session, error;\n\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.prev = 0;\n\n                if (currentSession) {\n                  _context14.next = 10;\n                  break;\n                }\n\n                _context14.next = 4;\n                return this.getSession();\n\n              case 4:\n                _yield$this$getSessio3 = _context14.sent;\n                data = _yield$this$getSessio3.data;\n                _error3 = _yield$this$getSessio3.error;\n\n                if (!_error3) {\n                  _context14.next = 9;\n                  break;\n                }\n\n                throw _error3;\n\n              case 9:\n                currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n\n              case 10:\n                if (currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token) {\n                  _context14.next = 12;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 12:\n                _context14.next = 14;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 14:\n                _yield$this$_callRefr3 = _context14.sent;\n                session = _yield$this$_callRefr3.session;\n                error = _yield$this$_callRefr3.error;\n\n                if (!error) {\n                  _context14.next = 19;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 19:\n                if (session) {\n                  _context14.next = 21;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: null\n                });\n\n              case 21:\n                return _context14.abrupt(\"return\", {\n                  data: {\n                    user: session.user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 24:\n                _context14.prev = 24;\n                _context14.t0 = _context14[\"catch\"](0);\n\n                if (!isAuthError(_context14.t0)) {\n                  _context14.next = 28;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context14.t0\n                });\n\n              case 28:\n                throw _context14.t0;\n\n              case 29:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this, [[0, 24]]);\n      }));\n    }\n    /**\n     * Gets the session data from a URL string\n     */\n\n  }, {\n    key: \"_getSessionFromUrl\",\n    value: function _getSessionFromUrl(isPKCEFlow) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var authCode, _yield$this$exchangeC, _data, _error4, error_description, error_code, _error5, provider_token, provider_refresh_token, access_token, expires_in, refresh_token, token_type, timeNow, expires_at, _yield$this$getUser2, data, error, user, session, redirectType;\n\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.prev = 0;\n\n                if (isBrowser()) {\n                  _context15.next = 3;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No browser detected.');\n\n              case 3:\n                if (!(this.flowType === 'implicit' && !this._isImplicitGrantFlow())) {\n                  _context15.next = 7;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n\n              case 7:\n                if (!(this.flowType == 'pkce' && !isPKCEFlow)) {\n                  _context15.next = 9;\n                  break;\n                }\n\n                throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.');\n\n              case 9:\n                if (!isPKCEFlow) {\n                  _context15.next = 23;\n                  break;\n                }\n\n                authCode = getParameterByName('code');\n\n                if (authCode) {\n                  _context15.next = 13;\n                  break;\n                }\n\n                throw new AuthPKCEGrantCodeExchangeError('No code detected.');\n\n              case 13:\n                _context15.next = 15;\n                return this.exchangeCodeForSession(authCode);\n\n              case 15:\n                _yield$this$exchangeC = _context15.sent;\n                _data = _yield$this$exchangeC.data;\n                _error4 = _yield$this$exchangeC.error;\n\n                if (!_error4) {\n                  _context15.next = 20;\n                  break;\n                }\n\n                throw _error4;\n\n              case 20:\n                if (_data.session) {\n                  _context15.next = 22;\n                  break;\n                }\n\n                throw new AuthPKCEGrantCodeExchangeError('No session detected.');\n\n              case 22:\n                return _context15.abrupt(\"return\", {\n                  data: {\n                    session: _data.session,\n                    redirectType: null\n                  },\n                  error: null\n                });\n\n              case 23:\n                error_description = getParameterByName('error_description');\n\n                if (!error_description) {\n                  _context15.next = 32;\n                  break;\n                }\n\n                error_code = getParameterByName('error_code');\n\n                if (error_code) {\n                  _context15.next = 28;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No error_code detected.');\n\n              case 28:\n                _error5 = getParameterByName('error');\n\n                if (_error5) {\n                  _context15.next = 31;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No error detected.');\n\n              case 31:\n                throw new AuthImplicitGrantRedirectError(error_description, {\n                  error: _error5,\n                  code: error_code\n                });\n\n              case 32:\n                provider_token = getParameterByName('provider_token');\n                provider_refresh_token = getParameterByName('provider_refresh_token');\n                access_token = getParameterByName('access_token');\n\n                if (access_token) {\n                  _context15.next = 37;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No access_token detected.');\n\n              case 37:\n                expires_in = getParameterByName('expires_in');\n\n                if (expires_in) {\n                  _context15.next = 40;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n\n              case 40:\n                refresh_token = getParameterByName('refresh_token');\n\n                if (refresh_token) {\n                  _context15.next = 43;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n\n              case 43:\n                token_type = getParameterByName('token_type');\n\n                if (token_type) {\n                  _context15.next = 46;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No token_type detected.');\n\n              case 46:\n                timeNow = Math.round(Date.now() / 1000);\n                expires_at = timeNow + parseInt(expires_in);\n                _context15.next = 50;\n                return this.getUser(access_token);\n\n              case 50:\n                _yield$this$getUser2 = _context15.sent;\n                data = _yield$this$getUser2.data;\n                error = _yield$this$getUser2.error;\n\n                if (!error) {\n                  _context15.next = 55;\n                  break;\n                }\n\n                throw error;\n\n              case 55:\n                user = data.user;\n                session = {\n                  provider_token: provider_token,\n                  provider_refresh_token: provider_refresh_token,\n                  access_token: access_token,\n                  expires_in: parseInt(expires_in),\n                  expires_at: expires_at,\n                  refresh_token: refresh_token,\n                  token_type: token_type,\n                  user: user\n                };\n                redirectType = getParameterByName('type'); // Remove tokens from URL\n\n                window.location.hash = '';\n                return _context15.abrupt(\"return\", {\n                  data: {\n                    session: session,\n                    redirectType: redirectType\n                  },\n                  error: null\n                });\n\n              case 62:\n                _context15.prev = 62;\n                _context15.t0 = _context15[\"catch\"](0);\n\n                if (!isAuthError(_context15.t0)) {\n                  _context15.next = 66;\n                  break;\n                }\n\n                return _context15.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    redirectType: null\n                  },\n                  error: _context15.t0\n                });\n\n              case 66:\n                throw _context15.t0;\n\n              case 67:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this, [[0, 62]]);\n      }));\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     */\n\n  }, {\n    key: \"_isImplicitGrantFlow\",\n    value: function _isImplicitGrantFlow() {\n      return isBrowser() && (Boolean(getParameterByName('access_token')) || Boolean(getParameterByName('error_description')));\n    }\n    /**\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n     */\n\n  }, {\n    key: \"_isPKCEFlow\",\n    value: function _isPKCEFlow() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var currentStorageContent;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return getItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n\n              case 2:\n                currentStorageContent = _context16.sent;\n                return _context16.abrupt(\"return\", isBrowser() && Boolean(getParameterByName('code')) && Boolean(currentStorageContent));\n\n              case 4:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     */\n\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var _yield$this$getSessio4, data, sessionError, accessToken, _yield$this$admin$sig, error;\n\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this.getSession();\n\n              case 2:\n                _yield$this$getSessio4 = _context17.sent;\n                data = _yield$this$getSessio4.data;\n                sessionError = _yield$this$getSessio4.error;\n\n                if (!sessionError) {\n                  _context17.next = 7;\n                  break;\n                }\n\n                return _context17.abrupt(\"return\", {\n                  error: sessionError\n                });\n\n              case 7:\n                accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n\n                if (!accessToken) {\n                  _context17.next = 16;\n                  break;\n                }\n\n                _context17.next = 11;\n                return this.admin.signOut(accessToken);\n\n              case 11:\n                _yield$this$admin$sig = _context17.sent;\n                error = _yield$this$admin$sig.error;\n\n                if (!error) {\n                  _context17.next = 16;\n                  break;\n                }\n\n                if (isAuthApiError(error) && (error.status === 404 || error.status === 401)) {\n                  _context17.next = 16;\n                  break;\n                }\n\n                return _context17.abrupt(\"return\", {\n                  error: error\n                });\n\n              case 16:\n                _context17.next = 18;\n                return this._removeSession();\n\n              case 18:\n                _context17.next = 20;\n                return removeItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n\n              case 20:\n                this._notifyAllSubscribers('SIGNED_OUT', null);\n\n                return _context17.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 22:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @param callback A callback function to be invoked when an auth event happens.\n     */\n\n  }, {\n    key: \"onAuthStateChange\",\n    value: function onAuthStateChange(callback) {\n      var _this3 = this;\n\n      var id = uuid();\n      var subscription = {\n        id: id,\n        callback: callback,\n        unsubscribe: function unsubscribe() {\n          _this3.stateChangeEmitters.delete(id);\n        }\n      };\n      this.stateChangeEmitters.set(id, subscription);\n      this.emitInitialSession(id);\n      return {\n        data: {\n          subscription: subscription\n        }\n      };\n    }\n  }, {\n    key: \"emitInitialSession\",\n    value: function emitInitialSession(id) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var _yield$this$getSessio5, session, error;\n\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.prev = 0;\n                _context18.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio5 = _context18.sent;\n                session = _yield$this$getSessio5.data.session;\n                error = _yield$this$getSessio5.error;\n\n                if (!error) {\n                  _context18.next = 8;\n                  break;\n                }\n\n                throw error;\n\n              case 8:\n                (_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback('INITIAL_SESSION', session);\n                _context18.next = 15;\n                break;\n\n              case 11:\n                _context18.prev = 11;\n                _context18.t0 = _context18[\"catch\"](0);\n                (_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback('INITIAL_SESSION', null);\n                console.error(_context18.t0);\n\n              case 15:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this, [[0, 11]]);\n      }));\n    }\n    /**\n     * Sends a password reset request to an email address.\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */\n\n  }, {\n    key: \"resetPasswordForEmail\",\n    value: function resetPasswordForEmail(email) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n        var codeChallenge, codeChallengeMethod, codeVerifier;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                codeChallenge = null;\n                codeChallengeMethod = null;\n\n                if (!(this.flowType === 'pkce')) {\n                  _context19.next = 10;\n                  break;\n                }\n\n                codeVerifier = generatePKCEVerifier();\n                _context19.next = 6;\n                return setItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"), codeVerifier);\n\n              case 6:\n                _context19.next = 8;\n                return generatePKCEChallenge(codeVerifier);\n\n              case 8:\n                codeChallenge = _context19.sent;\n                codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n\n              case 10:\n                _context19.prev = 10;\n                _context19.next = 13;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/recover\"), {\n                  body: {\n                    email: email,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod,\n                    gotrue_meta_security: {\n                      captcha_token: options.captchaToken\n                    }\n                  },\n                  headers: this.headers,\n                  redirectTo: options.redirectTo\n                });\n\n              case 13:\n                return _context19.abrupt(\"return\", _context19.sent);\n\n              case 16:\n                _context19.prev = 16;\n                _context19.t0 = _context19[\"catch\"](10);\n\n                if (!isAuthError(_context19.t0)) {\n                  _context19.next = 20;\n                  break;\n                }\n\n                return _context19.abrupt(\"return\", {\n                  data: null,\n                  error: _context19.t0\n                });\n\n              case 20:\n                throw _context19.t0;\n\n              case 21:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this, [[10, 16]]);\n      }));\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n\n  }, {\n    key: \"_refreshAccessToken\",\n    value: function _refreshAccessToken(refreshToken) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n        var _this4 = this;\n\n        var startedAt;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.prev = 0;\n                startedAt = Date.now(); // will attempt to refresh the token with exponential backoff\n\n                _context21.next = 4;\n                return retryable(function (attempt) {\n                  return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n                    return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n                      while (1) {\n                        switch (_context20.prev = _context20.next) {\n                          case 0:\n                            _context20.next = 2;\n                            return sleep(attempt * 200);\n\n                          case 2:\n                            _context20.next = 4;\n                            return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=refresh_token\"), {\n                              body: {\n                                refresh_token: refreshToken\n                              },\n                              headers: this.headers,\n                              xform: _sessionResponse\n                            });\n\n                          case 4:\n                            return _context20.abrupt(\"return\", _context20.sent);\n\n                          case 5:\n                          case \"end\":\n                            return _context20.stop();\n                        }\n                      }\n                    }, _callee20, this);\n                  }));\n                }, function (attempt, _, result) {\n                  return result && result.error && result.error instanceof AuthRetryableFetchError && // retryable only if the request can be sent before the backoff overflows the tick duration\n                  Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION;\n                });\n\n              case 4:\n                return _context21.abrupt(\"return\", _context21.sent);\n\n              case 7:\n                _context21.prev = 7;\n                _context21.t0 = _context21[\"catch\"](0);\n\n                if (!isAuthError(_context21.t0)) {\n                  _context21.next = 11;\n                  break;\n                }\n\n                return _context21.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    user: null\n                  },\n                  error: _context21.t0\n                });\n\n              case 11:\n                throw _context21.t0;\n\n              case 12:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, null, [[0, 7]]);\n      }));\n    }\n  }, {\n    key: \"_isValidSession\",\n    value: function _isValidSession(maybeSession) {\n      var isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;\n      return isValidSession;\n    }\n  }, {\n    key: \"_handleProviderSignIn\",\n    value: function _handleProviderSignIn(provider, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {\n        var url;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _context22.next = 2;\n                return this._getUrlForProvider(provider, {\n                  redirectTo: options.redirectTo,\n                  scopes: options.scopes,\n                  queryParams: options.queryParams\n                });\n\n              case 2:\n                url = _context22.sent;\n\n                // try to open on the browser\n                if (isBrowser() && !options.skipBrowserRedirect) {\n                  window.location.assign(url);\n                }\n\n                return _context22.abrupt(\"return\", {\n                  data: {\n                    provider: provider,\n                    url: url\n                  },\n                  error: null\n                });\n\n              case 5:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n\n  }, {\n    key: \"_recoverAndRefresh\",\n    value: function _recoverAndRefresh() {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {\n        var currentSession, timeNow, _yield$this$_callRefr4, error;\n\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.prev = 0;\n                _context23.next = 3;\n                return getItemAsync(this.storage, this.storageKey);\n\n              case 3:\n                currentSession = _context23.sent;\n\n                if (this._isValidSession(currentSession)) {\n                  _context23.next = 9;\n                  break;\n                }\n\n                if (!(currentSession !== null)) {\n                  _context23.next = 8;\n                  break;\n                }\n\n                _context23.next = 8;\n                return this._removeSession();\n\n              case 8:\n                return _context23.abrupt(\"return\");\n\n              case 9:\n                timeNow = Math.round(Date.now() / 1000);\n\n                if (!(((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN)) {\n                  _context23.next = 26;\n                  break;\n                }\n\n                if (!(this.autoRefreshToken && currentSession.refresh_token)) {\n                  _context23.next = 22;\n                  break;\n                }\n\n                _context23.next = 14;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 14:\n                _yield$this$_callRefr4 = _context23.sent;\n                error = _yield$this$_callRefr4.error;\n\n                if (!error) {\n                  _context23.next = 20;\n                  break;\n                }\n\n                console.log(error.message);\n                _context23.next = 20;\n                return this._removeSession();\n\n              case 20:\n                _context23.next = 24;\n                break;\n\n              case 22:\n                _context23.next = 24;\n                return this._removeSession();\n\n              case 24:\n                _context23.next = 30;\n                break;\n\n              case 26:\n                if (!this.persistSession) {\n                  _context23.next = 29;\n                  break;\n                }\n\n                _context23.next = 29;\n                return this._saveSession(currentSession);\n\n              case 29:\n                this._notifyAllSubscribers('SIGNED_IN', currentSession);\n\n              case 30:\n                _context23.next = 36;\n                break;\n\n              case 32:\n                _context23.prev = 32;\n                _context23.t0 = _context23[\"catch\"](0);\n                console.error(_context23.t0);\n                return _context23.abrupt(\"return\");\n\n              case 36:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this, [[0, 32]]);\n      }));\n    }\n  }, {\n    key: \"_callRefreshToken\",\n    value: function _callRefreshToken(refreshToken) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {\n        var _yield$this$_refreshA, data, error, result, _result;\n\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                if (!this.refreshingDeferred) {\n                  _context24.next = 2;\n                  break;\n                }\n\n                return _context24.abrupt(\"return\", this.refreshingDeferred.promise);\n\n              case 2:\n                _context24.prev = 2;\n                this.refreshingDeferred = new Deferred();\n\n                if (refreshToken) {\n                  _context24.next = 6;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 6:\n                _context24.next = 8;\n                return this._refreshAccessToken(refreshToken);\n\n              case 8:\n                _yield$this$_refreshA = _context24.sent;\n                data = _yield$this$_refreshA.data;\n                error = _yield$this$_refreshA.error;\n\n                if (!error) {\n                  _context24.next = 13;\n                  break;\n                }\n\n                throw error;\n\n              case 13:\n                if (data.session) {\n                  _context24.next = 15;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 15:\n                _context24.next = 17;\n                return this._saveSession(data.session);\n\n              case 17:\n                this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n\n                result = {\n                  session: data.session,\n                  error: null\n                };\n                this.refreshingDeferred.resolve(result);\n                return _context24.abrupt(\"return\", result);\n\n              case 23:\n                _context24.prev = 23;\n                _context24.t0 = _context24[\"catch\"](2);\n\n                if (!isAuthError(_context24.t0)) {\n                  _context24.next = 29;\n                  break;\n                }\n\n                _result = {\n                  session: null,\n                  error: _context24.t0\n                };\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(_result);\n                return _context24.abrupt(\"return\", _result);\n\n              case 29:\n                (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(_context24.t0);\n                throw _context24.t0;\n\n              case 31:\n                _context24.prev = 31;\n                this.refreshingDeferred = null;\n                return _context24.finish(31);\n\n              case 34:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this, [[2, 23, 31, 34]]);\n      }));\n    }\n  }, {\n    key: \"_notifyAllSubscribers\",\n    value: function _notifyAllSubscribers(event, session) {\n      var broadcast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      if (this.broadcastChannel && broadcast) {\n        this.broadcastChannel.postMessage({\n          event: event,\n          session: session\n        });\n      }\n\n      this.stateChangeEmitters.forEach(function (x) {\n        return x.callback(event, session);\n      });\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n\n  }, {\n    key: \"_saveSession\",\n    value: function _saveSession(session) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                if (!this.persistSession) {\n                  this.inMemorySession = session;\n                }\n\n                if (!(this.persistSession && session.expires_at)) {\n                  _context25.next = 4;\n                  break;\n                }\n\n                _context25.next = 4;\n                return this._persistSession(session);\n\n              case 4:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n    }\n  }, {\n    key: \"_persistSession\",\n    value: function _persistSession(currentSession) {\n      return setItemAsync(this.storage, this.storageKey, currentSession);\n    }\n  }, {\n    key: \"_removeSession\",\n    value: function _removeSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                if (!this.persistSession) {\n                  _context26.next = 5;\n                  break;\n                }\n\n                _context26.next = 3;\n                return removeItemAsync(this.storage, this.storageKey);\n\n              case 3:\n                _context26.next = 6;\n                break;\n\n              case 5:\n                this.inMemorySession = null;\n\n              case 6:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */\n\n  }, {\n    key: \"_removeVisibilityChangedCallback\",\n    value: function _removeVisibilityChangedCallback() {\n      var callback = this.visibilityChangedCallback;\n      this.visibilityChangedCallback = null;\n\n      try {\n        if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n          window.removeEventListener('visibilitychange', callback);\n        }\n      } catch (e) {\n        console.error('removing visibilitychange callback failed', e);\n      }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */\n\n  }, {\n    key: \"_startAutoRefresh\",\n    value: function _startAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {\n        var _this5 = this;\n\n        var ticker;\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                _context27.next = 2;\n                return this._stopAutoRefresh();\n\n              case 2:\n                ticker = setInterval(function () {\n                  return _this5._autoRefreshTokenTick();\n                }, AUTO_REFRESH_TICK_DURATION);\n                this.autoRefreshTicker = ticker;\n\n                if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n                  // ticker is a NodeJS Timeout object that has an `unref` method\n                  // https://nodejs.org/api/timers.html#timeoutunref\n                  // When auto refresh is used in NodeJS (like for testing) the\n                  // `setInterval` is preventing the process from being marked as\n                  // finished and tests run endlessly. This can be prevented by calling\n                  // `unref()` on the returned object.\n                  ticker.unref(); // @ts-ignore\n                } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {\n                  // similar like for NodeJS, but with the Deno API\n                  // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n                  // @ts-ignore\n                  Deno.unrefTimer(ticker);\n                } // run the tick immediately\n\n\n                _context27.next = 7;\n                return this._autoRefreshTokenTick();\n\n              case 7:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */\n\n  }, {\n    key: \"_stopAutoRefresh\",\n    value: function _stopAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n        var ticker;\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                ticker = this.autoRefreshTicker;\n                this.autoRefreshTicker = null;\n\n                if (ticker) {\n                  clearInterval(ticker);\n                }\n\n              case 3:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desireable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */\n\n  }, {\n    key: \"startAutoRefresh\",\n    value: function startAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                this._removeVisibilityChangedCallback();\n\n                _context29.next = 3;\n                return this._startAutoRefresh();\n\n              case 3:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, this);\n      }));\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */\n\n  }, {\n    key: \"stopAutoRefresh\",\n    value: function stopAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                this._removeVisibilityChangedCallback();\n\n                _context30.next = 3;\n                return this._stopAutoRefresh();\n\n              case 3:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30, this);\n      }));\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */\n\n  }, {\n    key: \"_autoRefreshTokenTick\",\n    value: function _autoRefreshTokenTick() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {\n        var now, _yield$this$getSessio6, session, expiresInTicks;\n\n        return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                now = Date.now();\n                _context31.prev = 1;\n                _context31.next = 4;\n                return this.getSession();\n\n              case 4:\n                _yield$this$getSessio6 = _context31.sent;\n                session = _yield$this$getSessio6.data.session;\n\n                if (!(!session || !session.refresh_token || !session.expires_at)) {\n                  _context31.next = 8;\n                  break;\n                }\n\n                return _context31.abrupt(\"return\");\n\n              case 8:\n                // session will expire in this many ticks (or has already expired if <= 0)\n                expiresInTicks = Math.floor((session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION);\n\n                if (!(expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD)) {\n                  _context31.next = 12;\n                  break;\n                }\n\n                _context31.next = 12;\n                return this._callRefreshToken(session.refresh_token);\n\n              case 12:\n                _context31.next = 17;\n                break;\n\n              case 14:\n                _context31.prev = 14;\n                _context31.t0 = _context31[\"catch\"](1);\n                console.error('Auto refresh tick failed with error. This is likely a transient error.', _context31.t0);\n\n              case 17:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee31, this, [[1, 14]]);\n      }));\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */\n\n  }, {\n    key: \"_handleVisibilityChange\",\n    value: function _handleVisibilityChange() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {\n        var _this6 = this;\n\n        return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n          while (1) {\n            switch (_context33.prev = _context33.next) {\n              case 0:\n                if (!(!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener))) {\n                  _context33.next = 3;\n                  break;\n                }\n\n                if (this.autoRefreshToken) {\n                  // in non-browser environments the refresh token ticker runs always\n                  this.startAutoRefresh();\n                }\n\n                return _context33.abrupt(\"return\", false);\n\n              case 3:\n                _context33.prev = 3;\n\n                this.visibilityChangedCallback = function () {\n                  return __awaiter(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {\n                    return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n                      while (1) {\n                        switch (_context32.prev = _context32.next) {\n                          case 0:\n                            _context32.next = 2;\n                            return this._onVisibilityChanged(false);\n\n                          case 2:\n                            return _context32.abrupt(\"return\", _context32.sent);\n\n                          case 3:\n                          case \"end\":\n                            return _context32.stop();\n                        }\n                      }\n                    }, _callee32, this);\n                  }));\n                };\n\n                window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback); // now immediately call the visbility changed callback to setup with the\n                // current visbility state\n\n                _context33.next = 8;\n                return this._onVisibilityChanged(true);\n\n              case 8:\n                _context33.next = 13;\n                break;\n\n              case 10:\n                _context33.prev = 10;\n                _context33.t0 = _context33[\"catch\"](3);\n                console.error('_handleVisibilityChange', _context33.t0);\n\n              case 13:\n              case \"end\":\n                return _context33.stop();\n            }\n          }\n        }, _callee33, this, [[3, 10]]);\n      }));\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */\n\n  }, {\n    key: \"_onVisibilityChanged\",\n    value: function _onVisibilityChanged(isInitial) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee34() {\n        return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n          while (1) {\n            switch (_context34.prev = _context34.next) {\n              case 0:\n                if (!(document.visibilityState === 'visible')) {\n                  _context34.next = 9;\n                  break;\n                }\n\n                if (isInitial) {\n                  _context34.next = 6;\n                  break;\n                }\n\n                _context34.next = 4;\n                return this.initializePromise;\n\n              case 4:\n                _context34.next = 6;\n                return this._recoverAndRefresh();\n\n              case 6:\n                if (this.autoRefreshToken) {\n                  // in browser environments the refresh token ticker runs only on focused tabs\n                  // which prevents race conditions\n                  this._startAutoRefresh();\n                }\n\n                _context34.next = 10;\n                break;\n\n              case 9:\n                if (document.visibilityState === 'hidden') {\n                  if (this.autoRefreshToken) {\n                    this._stopAutoRefresh();\n                  }\n                }\n\n              case 10:\n              case \"end\":\n                return _context34.stop();\n            }\n          }\n        }, _callee34, this);\n      }));\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */\n\n  }, {\n    key: \"_getUrlForProvider\",\n    value: function _getUrlForProvider(provider, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee35() {\n        var urlParams, codeVerifier, codeChallenge, codeChallengeMethod, flowParams, query;\n        return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n          while (1) {\n            switch (_context35.prev = _context35.next) {\n              case 0:\n                urlParams = [\"provider=\".concat(encodeURIComponent(provider))];\n\n                if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n                  urlParams.push(\"redirect_to=\".concat(encodeURIComponent(options.redirectTo)));\n                }\n\n                if (options === null || options === void 0 ? void 0 : options.scopes) {\n                  urlParams.push(\"scopes=\".concat(encodeURIComponent(options.scopes)));\n                }\n\n                if (!(this.flowType === 'pkce')) {\n                  _context35.next = 13;\n                  break;\n                }\n\n                codeVerifier = generatePKCEVerifier();\n                _context35.next = 7;\n                return setItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"), codeVerifier);\n\n              case 7:\n                _context35.next = 9;\n                return generatePKCEChallenge(codeVerifier);\n\n              case 9:\n                codeChallenge = _context35.sent;\n                codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n                flowParams = new URLSearchParams({\n                  code_challenge: \"\".concat(encodeURIComponent(codeChallenge)),\n                  code_challenge_method: \"\".concat(encodeURIComponent(codeChallengeMethod))\n                });\n                urlParams.push(flowParams.toString());\n\n              case 13:\n                if (options === null || options === void 0 ? void 0 : options.queryParams) {\n                  query = new URLSearchParams(options.queryParams);\n                  urlParams.push(query.toString());\n                }\n\n                return _context35.abrupt(\"return\", \"\".concat(this.url, \"/authorize?\").concat(urlParams.join('&')));\n\n              case 15:\n              case \"end\":\n                return _context35.stop();\n            }\n          }\n        }, _callee35, this);\n      }));\n    }\n  }, {\n    key: \"_unenroll\",\n    value: function _unenroll(params) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee36() {\n        var _yield$this$getSessio7, sessionData, sessionError;\n\n        return _regeneratorRuntime().wrap(function _callee36$(_context36) {\n          while (1) {\n            switch (_context36.prev = _context36.next) {\n              case 0:\n                _context36.prev = 0;\n                _context36.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio7 = _context36.sent;\n                sessionData = _yield$this$getSessio7.data;\n                sessionError = _yield$this$getSessio7.error;\n\n                if (!sessionError) {\n                  _context36.next = 8;\n                  break;\n                }\n\n                return _context36.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 8:\n                _context36.next = 10;\n                return _request(this.fetch, 'DELETE', \"\".concat(this.url, \"/factors/\").concat(params.factorId), {\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n\n              case 10:\n                return _context36.abrupt(\"return\", _context36.sent);\n\n              case 13:\n                _context36.prev = 13;\n                _context36.t0 = _context36[\"catch\"](0);\n\n                if (!isAuthError(_context36.t0)) {\n                  _context36.next = 17;\n                  break;\n                }\n\n                return _context36.abrupt(\"return\", {\n                  data: null,\n                  error: _context36.t0\n                });\n\n              case 17:\n                throw _context36.t0;\n\n              case 18:\n              case \"end\":\n                return _context36.stop();\n            }\n          }\n        }, _callee36, this, [[0, 13]]);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#enroll}\n     */\n\n  }, {\n    key: \"_enroll\",\n    value: function _enroll(params) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {\n        var _yield$this$getSessio8, sessionData, sessionError, _yield$_request6, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee37$(_context37) {\n          while (1) {\n            switch (_context37.prev = _context37.next) {\n              case 0:\n                _context37.prev = 0;\n                _context37.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio8 = _context37.sent;\n                sessionData = _yield$this$getSessio8.data;\n                sessionError = _yield$this$getSessio8.error;\n\n                if (!sessionError) {\n                  _context37.next = 8;\n                  break;\n                }\n\n                return _context37.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 8:\n                _context37.next = 10;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors\"), {\n                  body: {\n                    friendly_name: params.friendlyName,\n                    factor_type: params.factorType,\n                    issuer: params.issuer\n                  },\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n\n              case 10:\n                _yield$_request6 = _context37.sent;\n                data = _yield$_request6.data;\n                error = _yield$_request6.error;\n\n                if (!error) {\n                  _context37.next = 15;\n                  break;\n                }\n\n                return _context37.abrupt(\"return\", {\n                  data: null,\n                  error: error\n                });\n\n              case 15:\n                if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n                  data.totp.qr_code = \"data:image/svg+xml;utf-8,\".concat(data.totp.qr_code);\n                }\n\n                return _context37.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 19:\n                _context37.prev = 19;\n                _context37.t0 = _context37[\"catch\"](0);\n\n                if (!isAuthError(_context37.t0)) {\n                  _context37.next = 23;\n                  break;\n                }\n\n                return _context37.abrupt(\"return\", {\n                  data: null,\n                  error: _context37.t0\n                });\n\n              case 23:\n                throw _context37.t0;\n\n              case 24:\n              case \"end\":\n                return _context37.stop();\n            }\n          }\n        }, _callee37, this, [[0, 19]]);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#verify}\n     */\n\n  }, {\n    key: \"_verify\",\n    value: function _verify(params) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee38() {\n        var _yield$this$getSessio9, sessionData, sessionError, _yield$_request7, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee38$(_context38) {\n          while (1) {\n            switch (_context38.prev = _context38.next) {\n              case 0:\n                _context38.prev = 0;\n                _context38.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio9 = _context38.sent;\n                sessionData = _yield$this$getSessio9.data;\n                sessionError = _yield$this$getSessio9.error;\n\n                if (!sessionError) {\n                  _context38.next = 8;\n                  break;\n                }\n\n                return _context38.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 8:\n                _context38.next = 10;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/verify\"), {\n                  body: {\n                    code: params.code,\n                    challenge_id: params.challengeId\n                  },\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n\n              case 10:\n                _yield$_request7 = _context38.sent;\n                data = _yield$_request7.data;\n                error = _yield$_request7.error;\n\n                if (!error) {\n                  _context38.next = 15;\n                  break;\n                }\n\n                return _context38.abrupt(\"return\", {\n                  data: null,\n                  error: error\n                });\n\n              case 15:\n                _context38.next = 17;\n                return this._saveSession(Object.assign({\n                  expires_at: Math.round(Date.now() / 1000) + data.expires_in\n                }, data));\n\n              case 17:\n                this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n\n                return _context38.abrupt(\"return\", {\n                  data: data,\n                  error: error\n                });\n\n              case 21:\n                _context38.prev = 21;\n                _context38.t0 = _context38[\"catch\"](0);\n\n                if (!isAuthError(_context38.t0)) {\n                  _context38.next = 25;\n                  break;\n                }\n\n                return _context38.abrupt(\"return\", {\n                  data: null,\n                  error: _context38.t0\n                });\n\n              case 25:\n                throw _context38.t0;\n\n              case 26:\n              case \"end\":\n                return _context38.stop();\n            }\n          }\n        }, _callee38, this, [[0, 21]]);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#challenge}\n     */\n\n  }, {\n    key: \"_challenge\",\n    value: function _challenge(params) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {\n        var _yield$this$getSessio10, sessionData, sessionError;\n\n        return _regeneratorRuntime().wrap(function _callee39$(_context39) {\n          while (1) {\n            switch (_context39.prev = _context39.next) {\n              case 0:\n                _context39.prev = 0;\n                _context39.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio10 = _context39.sent;\n                sessionData = _yield$this$getSessio10.data;\n                sessionError = _yield$this$getSessio10.error;\n\n                if (!sessionError) {\n                  _context39.next = 8;\n                  break;\n                }\n\n                return _context39.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 8:\n                _context39.next = 10;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/challenge\"), {\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n\n              case 10:\n                return _context39.abrupt(\"return\", _context39.sent);\n\n              case 13:\n                _context39.prev = 13;\n                _context39.t0 = _context39[\"catch\"](0);\n\n                if (!isAuthError(_context39.t0)) {\n                  _context39.next = 17;\n                  break;\n                }\n\n                return _context39.abrupt(\"return\", {\n                  data: null,\n                  error: _context39.t0\n                });\n\n              case 17:\n                throw _context39.t0;\n\n              case 18:\n              case \"end\":\n                return _context39.stop();\n            }\n          }\n        }, _callee39, this, [[0, 13]]);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */\n\n  }, {\n    key: \"_challengeAndVerify\",\n    value: function _challengeAndVerify(params) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {\n        var _yield$this$_challeng, challengeData, challengeError;\n\n        return _regeneratorRuntime().wrap(function _callee40$(_context40) {\n          while (1) {\n            switch (_context40.prev = _context40.next) {\n              case 0:\n                _context40.next = 2;\n                return this._challenge({\n                  factorId: params.factorId\n                });\n\n              case 2:\n                _yield$this$_challeng = _context40.sent;\n                challengeData = _yield$this$_challeng.data;\n                challengeError = _yield$this$_challeng.error;\n\n                if (!challengeError) {\n                  _context40.next = 7;\n                  break;\n                }\n\n                return _context40.abrupt(\"return\", {\n                  data: null,\n                  error: challengeError\n                });\n\n              case 7:\n                _context40.next = 9;\n                return this._verify({\n                  factorId: params.factorId,\n                  challengeId: challengeData.id,\n                  code: params.code\n                });\n\n              case 9:\n                return _context40.abrupt(\"return\", _context40.sent);\n\n              case 10:\n              case \"end\":\n                return _context40.stop();\n            }\n          }\n        }, _callee40, this);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */\n\n  }, {\n    key: \"_listFactors\",\n    value: function _listFactors() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee41() {\n        var _yield$this$getUser3, user, userError, factors, totp;\n\n        return _regeneratorRuntime().wrap(function _callee41$(_context41) {\n          while (1) {\n            switch (_context41.prev = _context41.next) {\n              case 0:\n                _context41.next = 2;\n                return this.getUser();\n\n              case 2:\n                _yield$this$getUser3 = _context41.sent;\n                user = _yield$this$getUser3.data.user;\n                userError = _yield$this$getUser3.error;\n\n                if (!userError) {\n                  _context41.next = 7;\n                  break;\n                }\n\n                return _context41.abrupt(\"return\", {\n                  data: null,\n                  error: userError\n                });\n\n              case 7:\n                factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n                totp = factors.filter(function (factor) {\n                  return factor.factor_type === 'totp' && factor.status === 'verified';\n                });\n                return _context41.abrupt(\"return\", {\n                  data: {\n                    all: factors,\n                    totp: totp\n                  },\n                  error: null\n                });\n\n              case 10:\n              case \"end\":\n                return _context41.stop();\n            }\n          }\n        }, _callee41, this);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */\n\n  }, {\n    key: \"_getAuthenticatorAssuranceLevel\",\n    value: function _getAuthenticatorAssuranceLevel() {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {\n        var _yield$this$getSessio11, session, sessionError, payload, currentLevel, nextLevel, verifiedFactors, currentAuthenticationMethods;\n\n        return _regeneratorRuntime().wrap(function _callee42$(_context42) {\n          while (1) {\n            switch (_context42.prev = _context42.next) {\n              case 0:\n                _context42.next = 2;\n                return this.getSession();\n\n              case 2:\n                _yield$this$getSessio11 = _context42.sent;\n                session = _yield$this$getSessio11.data.session;\n                sessionError = _yield$this$getSessio11.error;\n\n                if (!sessionError) {\n                  _context42.next = 7;\n                  break;\n                }\n\n                return _context42.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 7:\n                if (session) {\n                  _context42.next = 9;\n                  break;\n                }\n\n                return _context42.abrupt(\"return\", {\n                  data: {\n                    currentLevel: null,\n                    nextLevel: null,\n                    currentAuthenticationMethods: []\n                  },\n                  error: null\n                });\n\n              case 9:\n                payload = this._decodeJWT(session.access_token);\n                currentLevel = null;\n\n                if (payload.aal) {\n                  currentLevel = payload.aal;\n                }\n\n                nextLevel = currentLevel;\n                verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(function (factor) {\n                  return factor.status === 'verified';\n                })) !== null && _b !== void 0 ? _b : [];\n\n                if (verifiedFactors.length > 0) {\n                  nextLevel = 'aal2';\n                }\n\n                currentAuthenticationMethods = payload.amr || [];\n                return _context42.abrupt(\"return\", {\n                  data: {\n                    currentLevel: currentLevel,\n                    nextLevel: nextLevel,\n                    currentAuthenticationMethods: currentAuthenticationMethods\n                  },\n                  error: null\n                });\n\n              case 17:\n              case \"end\":\n                return _context42.stop();\n            }\n          }\n        }, _callee42, this);\n      }));\n    }\n  }]);\n\n  return GoTrueClient;\n}();\n\nexport { GoTrueClient as default };","map":{"version":3,"mappings":"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","names":["GoTrueAdminApi","DEFAULT_HEADERS","EXPIRY_MARGIN","GOTRUE_URL","STORAGE_KEY","AuthImplicitGrantRedirectError","AuthPKCEGrantCodeExchangeError","AuthInvalidCredentialsError","AuthRetryableFetchError","AuthSessionMissingError","AuthUnknownError","isAuthApiError","isAuthError","_request","_sessionResponse","_userResponse","_ssoResponse","decodeJWTPayload","Deferred","getItemAsync","getParameterByName","isBrowser","removeItemAsync","resolveFetch","setItemAsync","uuid","retryable","sleep","generatePKCEVerifier","generatePKCEChallenge","localStorageAdapter","polyfillGlobalThis","DEFAULT_OPTIONS","url","storageKey","autoRefreshToken","persistSession","detectSessionInUrl","headers","flowType","AUTO_REFRESH_TICK_DURATION","AUTO_REFRESH_TICK_THRESHOLD","GoTrueClient","options","Map","settings","inMemorySession","storage","admin","fetch","mfa","verify","_verify","bind","enroll","_enroll","unenroll","_unenroll","challenge","_challenge","listFactors","_listFactors","challengeAndVerify","_challengeAndVerify","getAuthenticatorAssuranceLevel","_getAuthenticatorAssuranceLevel","globalThis","BroadcastChannel","broadcastChannel","e","console","error","_a","addEventListener","event","_notifyAllSubscribers","data","session","initialize","initializePromise","_initialize","_isPKCEFlow","isPKCEFlow","_isImplicitGrantFlow","_getSessionFromUrl","_removeSession","redirectType","_saveSession","setTimeout","_recoverAndRefresh","_handleVisibilityChange","credentials","email","password","codeChallenge","codeChallengeMethod","codeVerifier","redirectTo","emailRedirectTo","body","gotrue_meta_security","captcha_token","captchaToken","code_challenge","code_challenge_method","xform","res","phone","_b","channel","_c","user","_handleProviderSignIn","provider","scopes","queryParams","skipBrowserRedirect","_d","authCode","auth_code","code_verifier","token","nonce","id_token","create_user","shouldCreateUser","_e","params","Error","access_token","provider_id","providerId","domain","redirect_to","undefined","skip_http_redirect","currentSession","maybeSession","_isValidSession","hasExpired","expires_at","Date","now","_callRefreshToken","refresh_token","jwt","getSession","attributes","sessionData","sessionError","userError","timeNow","expiresAt","payload","exp","refreshedSession","getUser","token_type","expires_in","exchangeCodeForSession","error_description","error_code","code","provider_token","provider_refresh_token","Math","round","parseInt","window","location","hash","Boolean","currentStorageContent","accessToken","signOut","status","callback","id","subscription","unsubscribe","stateChangeEmitters","delete","set","emitInitialSession","get","refreshToken","startedAt","attempt","__awaiter","_","result","isValidSession","_getUrlForProvider","assign","Infinity","log","message","refreshingDeferred","promise","_refreshAccessToken","resolve","reject","broadcast","postMessage","forEach","x","_persistSession","visibilityChangedCallback","removeEventListener","_stopAutoRefresh","ticker","setInterval","_autoRefreshTokenTick","autoRefreshTicker","unref","Deno","unrefTimer","clearInterval","_removeVisibilityChangedCallback","_startAutoRefresh","expiresInTicks","floor","startAutoRefresh","_onVisibilityChanged","isInitial","document","visibilityState","urlParams","encodeURIComponent","push","flowParams","URLSearchParams","toString","query","join","factorId","friendly_name","friendlyName","factor_type","factorType","issuer","totp","qr_code","challenge_id","challengeId","Object","challengeData","challengeError","factors","filter","factor","all","currentLevel","nextLevel","currentAuthenticationMethods","_decodeJWT","aal","verifiedFactors","length","amr"],"sources":["C:\\Users\\Adrian\\Documents\\web102\\web102_final\\client\\node_modules\\@supabase\\gotrue-js\\src\\GoTrueClient.ts"],"sourcesContent":["import GoTrueAdminApi from './GoTrueAdminApi'\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants'\nimport {\n  AuthError,\n  AuthImplicitGrantRedirectError,\n  AuthPKCEGrantCodeExchangeError,\n  AuthInvalidCredentialsError,\n  AuthRetryableFetchError,\n  AuthSessionMissingError,\n  AuthUnknownError,\n  isAuthApiError,\n  isAuthError,\n} from './lib/errors'\nimport { Fetch, _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch'\nimport {\n  decodeJWTPayload,\n  Deferred,\n  getItemAsync,\n  getParameterByName,\n  isBrowser,\n  removeItemAsync,\n  resolveFetch,\n  setItemAsync,\n  uuid,\n  retryable,\n  sleep,\n  generatePKCEVerifier,\n  generatePKCEChallenge,\n} from './lib/helpers'\nimport localStorageAdapter from './lib/local-storage'\nimport { polyfillGlobalThis } from './lib/polyfills'\n\nimport type {\n  AuthChangeEvent,\n  AuthResponse,\n  CallRefreshTokenResult,\n  GoTrueClientOptions,\n  InitializeResult,\n  OAuthResponse,\n  SSOResponse,\n  Provider,\n  Session,\n  SignInWithIdTokenCredentials,\n  SignInWithOAuthCredentials,\n  SignInWithPasswordCredentials,\n  SignInWithPasswordlessCredentials,\n  SignUpWithPasswordCredentials,\n  SignInWithSSO,\n  Subscription,\n  SupportedStorage,\n  User,\n  UserAttributes,\n  UserResponse,\n  VerifyOtpParams,\n  GoTrueMFAApi,\n  MFAEnrollParams,\n  AuthMFAEnrollResponse,\n  MFAChallengeParams,\n  AuthMFAChallengeResponse,\n  MFAUnenrollParams,\n  AuthMFAUnenrollResponse,\n  MFAVerifyParams,\n  AuthMFAVerifyResponse,\n  AuthMFAListFactorsResponse,\n  AMREntry,\n  AuthMFAGetAuthenticatorAssuranceLevelResponse,\n  AuthenticatorAssuranceLevels,\n  Factor,\n  MFAChallengeAndVerifyParams,\n  AuthFlowType,\n} from './lib/types'\n\npolyfillGlobalThis() // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS: Omit<Required<GoTrueClientOptions>, 'fetch' | 'storage'> = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n  flowType: 'implicit',\n}\n\n/** Current session will be checked for refresh at this interval. */\nconst AUTO_REFRESH_TICK_DURATION = 10 * 1000\n\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\nconst AUTO_REFRESH_TICK_THRESHOLD = 3\n\nexport default class GoTrueClient {\n  /**\n   * Namespace for the GoTrue admin methods.\n   * These methods should only be used in a trusted server-side environment.\n   */\n  admin: GoTrueAdminApi\n  /**\n   * Namespace for the MFA methods.\n   */\n  mfa: GoTrueMFAApi\n  /**\n   * The storage key used to identify the values saved in localStorage\n   */\n  protected storageKey: string\n\n  /**\n   * The session object for the currently logged in user. If null, it means there isn't a logged-in user.\n   * Only used if persistSession is false.\n   */\n  protected inMemorySession: Session | null\n\n  protected flowType: AuthFlowType\n\n  protected autoRefreshToken: boolean\n  protected persistSession: boolean\n  protected storage: SupportedStorage\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\n  protected autoRefreshTicker: ReturnType<typeof setInterval> | null = null\n  protected visibilityChangedCallback: (() => Promise<any>) | null = null\n  protected refreshingDeferred: Deferred<CallRefreshTokenResult> | null = null\n  /**\n   * Keeps track of the async client initialization.\n   * When null or not yet resolved the auth state is `unknown`\n   * Once resolved the the auth state is known and it's save to call any further client methods.\n   * Keep extra care to never reject or throw uncaught errors\n   */\n  protected initializePromise: Promise<InitializeResult> | null = null\n  protected detectSessionInUrl = true\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected fetch: Fetch\n\n  /**\n   * Used to broadcast state change events to other tabs listening.\n   */\n  protected broadcastChannel: BroadcastChannel | null = null\n\n  /**\n   * Create a new client for use in the browser.\n   */\n  constructor(options: GoTrueClientOptions) {\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n    this.inMemorySession = null\n    this.storageKey = settings.storageKey\n    this.autoRefreshToken = settings.autoRefreshToken\n    this.persistSession = settings.persistSession\n    this.storage = settings.storage || localStorageAdapter\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch,\n    })\n\n    this.url = settings.url\n    this.headers = settings.headers\n    this.fetch = resolveFetch(settings.fetch)\n    this.detectSessionInUrl = settings.detectSessionInUrl\n    this.flowType = settings.flowType\n\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n    }\n\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n      try {\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)\n      } catch (e: any) {\n        console.error(\n          'Failed to create a new BroadcastChannel, multi-tab state changes will not be available',\n          e\n        )\n      }\n\n      this.broadcastChannel?.addEventListener('message', (event) => {\n        this._notifyAllSubscribers(event.data.event, event.data.session, false) // broadcast = false so we don't get an endless loop of messages\n      })\n    }\n\n    this.initialize()\n  }\n\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n  initialize(): Promise<InitializeResult> {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize()\n    }\n\n    return this.initializePromise\n  }\n\n  /**\n   * IMPORTANT:\n   * 1. Never throw in this method, as it is called from the constructor\n   * 2. Never return a session from this method as it would be cached over\n   *    the whole lifetime of the client\n   */\n  private async _initialize(): Promise<InitializeResult> {\n    if (this.initializePromise) {\n      return this.initializePromise\n    }\n\n    try {\n      const isPKCEFlow = await this._isPKCEFlow()\n      if ((this.detectSessionInUrl && this._isImplicitGrantFlow()) || isPKCEFlow) {\n        const { data, error } = await this._getSessionFromUrl(isPKCEFlow)\n        if (error) {\n          // failed login attempt via url,\n          // remove old session as in verifyOtp, signUp and signInWith*\n          await this._removeSession()\n\n          return { error }\n        }\n\n        const { session, redirectType } = data\n\n        await this._saveSession(session)\n\n        setTimeout(() => {\n          if (redirectType === 'recovery') {\n            this._notifyAllSubscribers('PASSWORD_RECOVERY', session)\n          } else {\n            this._notifyAllSubscribers('SIGNED_IN', session)\n          }\n        }, 0)\n\n        return { error: null }\n      }\n\n      // no login attempt via callback url try to recover session from storage\n      await this._recoverAndRefresh()\n      return { error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { error }\n      }\n\n      return {\n        error: new AuthUnknownError('Unexpected error during initialization', error),\n      }\n    } finally {\n      await this._handleVisibilityChange()\n    }\n  }\n\n  /**\n   * Creates a new user.\n   *\n   * Be aware that if a user account exists in the system you may get back an\n   * error message that attempts to hide this information from the user.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUp(credentials: SignUpWithPasswordCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        let codeChallenge: string | null = null\n        let codeChallengeMethod: string | null = null\n        if (this.flowType === 'pkce') {\n          const codeVerifier = generatePKCEVerifier()\n          await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n          codeChallenge = await generatePKCEChallenge(codeVerifier)\n          codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n        }\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          redirectTo: options?.emailRedirectTo,\n          body: {\n            email,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            code_challenge: codeChallenge,\n            code_challenge_method: codeChallengeMethod,\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            data: options?.data ?? {},\n            channel: options?.channel ?? 'sms',\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n\n      const { data, error } = res\n\n      if (error || !data) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      const session: Session | null = data.session\n      const user: User | null = data.user\n\n      if (data.session) {\n        await this._saveSession(data.session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user with an email and password or phone and password.\n   *\n   * Be aware that you may get back an error message that will not distinguish\n   * between the cases where the account does not exist or that the\n   * email/phone and password combination is wrong or that the account can only\n   * be accessed via social login.\n   */\n  async signInWithPassword(credentials: SignInWithPasswordCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            email,\n            password,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n      const { data, error } = res\n      if (error || !data) return { data: { user: null, session: null }, error }\n      if (data.session) {\n        await this._saveSession(data.session)\n        this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user via a third-party provider.\n   */\n  async signInWithOAuth(credentials: SignInWithOAuthCredentials): Promise<OAuthResponse> {\n    await this._removeSession()\n\n    return await this._handleProviderSignIn(credentials.provider, {\n      redirectTo: credentials.options?.redirectTo,\n      scopes: credentials.options?.scopes,\n      queryParams: credentials.options?.queryParams,\n      skipBrowserRedirect: credentials.options?.skipBrowserRedirect,\n    })\n  }\n\n  /**\n   * Log in an existing user via a third-party provider.\n   */\n  async exchangeCodeForSession(authCode: string): Promise<AuthResponse> {\n    const codeVerifier = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n    const { data, error } = await _request(\n      this.fetch,\n      'POST',\n      `${this.url}/token?grant_type=pkce`,\n      {\n        headers: this.headers,\n        body: {\n          auth_code: authCode,\n          code_verifier: codeVerifier,\n        },\n        xform: _sessionResponse,\n      }\n    )\n    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n    if (error || !data) return { data: { user: null, session: null }, error }\n    if (data.session) {\n      await this._saveSession(data.session)\n      this._notifyAllSubscribers('SIGNED_IN', data.session)\n    }\n    return { data, error }\n  }\n\n  /**\n   * Allows signing in with an ID token issued by certain supported providers.\n   * The ID token is verified for validity and a new session is established.\n   *\n   * @experimental\n   */\n  async signInWithIdToken(credentials: SignInWithIdTokenCredentials): Promise<AuthResponse> {\n    await this._removeSession()\n\n    try {\n      const { options, provider, token, nonce } = credentials\n\n      const res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\n        headers: this.headers,\n        body: {\n          provider,\n          id_token: token,\n          nonce,\n          gotrue_meta_security: { captcha_token: options?.captchaToken },\n        },\n        xform: _sessionResponse,\n      })\n\n      const { data, error } = res\n      if (error || !data) return { data: { user: null, session: null }, error }\n      if (data.session) {\n        await this._saveSession(data.session)\n        this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Log in a user using magiclink or a one-time password (OTP).\n   *\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n   *\n   * Be aware that you may get back an error message that will not distinguish\n   * between the cases where the account does not exist or, that the account\n   * can only be accessed via social login.\n   *\n   * Do note that you will need to configure a Whatsapp sender on Twilio\n   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n   * channel is not supported on other providers\n   * at this time.\n   */\n  async signInWithOtp(credentials: SignInWithPasswordlessCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      if ('email' in credentials) {\n        const { email, options } = credentials\n        let codeChallenge: string | null = null\n        let codeChallengeMethod: string | null = null\n        if (this.flowType === 'pkce') {\n          const codeVerifier = generatePKCEVerifier()\n          await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n          codeChallenge = await generatePKCEChallenge(codeVerifier)\n          codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n        }\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            email,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            code_challenge: codeChallenge,\n            code_challenge_method: codeChallengeMethod,\n          },\n          redirectTo: options?.emailRedirectTo,\n        })\n        return { data: { user: null, session: null }, error }\n      }\n      if ('phone' in credentials) {\n        const { phone, options } = credentials\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            phone,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            channel: options?.channel ?? 'sms',\n          },\n        })\n        return { data: { user: null, session: null }, error }\n      }\n      throw new AuthInvalidCredentialsError('You must provide either an email or phone number.')\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   */\n  async verifyOtp(params: VerifyOtpParams): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/verify`, {\n        headers: this.headers,\n        body: {\n          ...params,\n          gotrue_meta_security: { captcha_token: params.options?.captchaToken },\n        },\n        redirectTo: params.options?.redirectTo,\n        xform: _sessionResponse,\n      })\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw new Error('An error occurred on token verification.')\n      }\n\n      const session: Session | null = data.session\n      const user: User = data.user\n\n      if (session?.access_token) {\n        await this._saveSession(session as Session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Attempts a single-sign on using an enterprise Identity Provider. A\n   * successful SSO attempt will redirect the current page to the identity\n   * provider authorization page. The redirect URL is implementation and SSO\n   * protocol specific.\n   *\n   * You can use it by providing a SSO domain. Typically you can extract this\n   * domain by asking users for their email address. If this domain is\n   * registered on the Auth instance the redirect will use that organization's\n   * currently active SSO Identity Provider for the login.\n   *\n   * If you have built an organization-specific login page, you can use the\n   * organization's SSO Identity Provider UUID directly instead.\n   */\n  async signInWithSSO(params: SignInWithSSO): Promise<SSOResponse> {\n    try {\n      await this._removeSession()\n\n      return await _request(this.fetch, 'POST', `${this.url}/sso`, {\n        body: {\n          ...('providerId' in params ? { provider_id: params.providerId } : null),\n          ...('domain' in params ? { domain: params.domain } : null),\n          redirect_to: params.options?.redirectTo ?? undefined,\n          ...(params?.options?.captchaToken\n            ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\n            : null),\n          skip_http_redirect: true, // fetch does not handle redirects\n        },\n        headers: this.headers,\n        xform: _ssoResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Returns the session, refreshing it if necessary.\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n   */\n  async getSession(): Promise<\n    | {\n        data: {\n          session: Session\n        }\n        error: null\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: AuthError\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: null\n      }\n  > {\n    // make sure we've read the session from the url if there is one\n    // save to just await, as long we make sure _initialize() never throws\n    await this.initializePromise\n\n    let currentSession: Session | null = null\n\n    if (this.persistSession) {\n      const maybeSession = await getItemAsync(this.storage, this.storageKey)\n\n      if (maybeSession !== null) {\n        if (this._isValidSession(maybeSession)) {\n          currentSession = maybeSession\n        } else {\n          await this._removeSession()\n        }\n      }\n    } else {\n      currentSession = this.inMemorySession\n    }\n\n    if (!currentSession) {\n      return { data: { session: null }, error: null }\n    }\n\n    const hasExpired = currentSession.expires_at\n      ? currentSession.expires_at <= Date.now() / 1000\n      : false\n    if (!hasExpired) {\n      return { data: { session: currentSession }, error: null }\n    }\n\n    const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n    if (error) {\n      return { data: { session: null }, error }\n    }\n\n    return { data: { session }, error: null }\n  }\n\n  /**\n   * Gets the current user details if there is an existing session.\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n   */\n  async getUser(jwt?: string): Promise<UserResponse> {\n    try {\n      if (!jwt) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        // Default to Authorization header if there is no existing session\n        jwt = data.session?.access_token ?? undefined\n      }\n\n      return await _request(this.fetch, 'GET', `${this.url}/user`, {\n        headers: this.headers,\n        jwt: jwt,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates user data for a logged in user.\n   */\n  async updateUser(\n    attributes: UserAttributes,\n    options: {\n      emailRedirectTo?: string | undefined\n    } = {}\n  ): Promise<UserResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        throw sessionError\n      }\n      if (!sessionData.session) {\n        throw new AuthSessionMissingError()\n      }\n      const session: Session = sessionData.session\n      const { data, error: userError } = await _request(this.fetch, 'PUT', `${this.url}/user`, {\n        headers: this.headers,\n        redirectTo: options?.emailRedirectTo,\n        body: attributes,\n        jwt: session.access_token,\n        xform: _userResponse,\n      })\n      if (userError) throw userError\n      session.user = data.user as User\n      await this._saveSession(session)\n      this._notifyAllSubscribers('USER_UPDATED', session)\n\n      return { data: { user: session.user }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Decodes a JWT (without performing any validation).\n   */\n  private _decodeJWT(jwt: string): {\n    exp?: number\n    aal?: AuthenticatorAssuranceLevels | null\n    amr?: AMREntry[] | null\n  } {\n    return decodeJWTPayload(jwt)\n  }\n\n  /**\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\n   * @param currentSession The current session that minimally contains an access token and refresh token.\n   */\n  async setSession(currentSession: {\n    access_token: string\n    refresh_token: string\n  }): Promise<AuthResponse> {\n    try {\n      if (!currentSession.access_token || !currentSession.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const timeNow = Date.now() / 1000\n      let expiresAt = timeNow\n      let hasExpired = true\n      let session: Session | null = null\n      const payload = decodeJWTPayload(currentSession.access_token)\n      if (payload.exp) {\n        expiresAt = payload.exp\n        hasExpired = expiresAt <= timeNow\n      }\n\n      if (hasExpired) {\n        const { session: refreshedSession, error } = await this._callRefreshToken(\n          currentSession.refresh_token\n        )\n        if (error) {\n          return { data: { user: null, session: null }, error: error }\n        }\n\n        if (!refreshedSession) {\n          return { data: { user: null, session: null }, error: null }\n        }\n        session = refreshedSession\n      } else {\n        const { data, error } = await this.getUser(currentSession.access_token)\n        if (error) {\n          throw error\n        }\n        session = {\n          access_token: currentSession.access_token,\n          refresh_token: currentSession.refresh_token,\n          user: data.user,\n          token_type: 'bearer',\n          expires_in: expiresAt - timeNow,\n          expires_at: expiresAt,\n        }\n        await this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Returns a new session, regardless of expiry status.\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n   * If the current session's refresh token is invalid, an error will be thrown.\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\n   */\n  async refreshSession(currentSession?: { refresh_token: string }): Promise<AuthResponse> {\n    try {\n      if (!currentSession) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        currentSession = data.session ?? undefined\n      }\n\n      if (!currentSession?.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n      if (error) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      if (!session) {\n        return { data: { user: null, session: null }, error: null }\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Gets the session data from a URL string\n   */\n  private async _getSessionFromUrl(isPKCEFlow: boolean): Promise<\n    | {\n        data: { session: Session; redirectType: string | null }\n        error: null\n      }\n    | { data: { session: null; redirectType: null }; error: AuthError }\n  > {\n    try {\n      if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.')\n      if (this.flowType === 'implicit' && !this._isImplicitGrantFlow()) {\n        throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.')\n      } else if (this.flowType == 'pkce' && !isPKCEFlow) {\n        throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.')\n      }\n      if (isPKCEFlow) {\n        const authCode = getParameterByName('code')\n        if (!authCode) throw new AuthPKCEGrantCodeExchangeError('No code detected.')\n        const { data, error } = await this.exchangeCodeForSession(authCode)\n        if (error) throw error\n        if (!data.session) throw new AuthPKCEGrantCodeExchangeError('No session detected.')\n        return { data: { session: data.session, redirectType: null }, error: null }\n      }\n\n      const error_description = getParameterByName('error_description')\n      if (error_description) {\n        const error_code = getParameterByName('error_code')\n        if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.')\n        const error = getParameterByName('error')\n        if (!error) throw new AuthImplicitGrantRedirectError('No error detected.')\n\n        throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code })\n      }\n\n      const provider_token = getParameterByName('provider_token')\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\n      const access_token = getParameterByName('access_token')\n      if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.')\n      const expires_in = getParameterByName('expires_in')\n      if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.')\n      const refresh_token = getParameterByName('refresh_token')\n      if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.')\n      const token_type = getParameterByName('token_type')\n      if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.')\n\n      const timeNow = Math.round(Date.now() / 1000)\n      const expires_at = timeNow + parseInt(expires_in)\n\n      const { data, error } = await this.getUser(access_token)\n      if (error) throw error\n      const user: User = data.user\n      const session: Session = {\n        provider_token,\n        provider_refresh_token,\n        access_token,\n        expires_in: parseInt(expires_in),\n        expires_at,\n        refresh_token,\n        token_type,\n        user,\n      }\n      const redirectType = getParameterByName('type')\n\n      // Remove tokens from URL\n      window.location.hash = ''\n\n      return { data: { session, redirectType }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, redirectType: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n   */\n  private _isImplicitGrantFlow(): boolean {\n    return (\n      isBrowser() &&\n      (Boolean(getParameterByName('access_token')) ||\n        Boolean(getParameterByName('error_description')))\n    )\n  }\n  /**\n   * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n   */\n  private async _isPKCEFlow(): Promise<boolean> {\n    const currentStorageContent = await getItemAsync(\n      this.storage,\n      `${this.storageKey}-code-verifier`\n    )\n    return isBrowser() && Boolean(getParameterByName('code')) && Boolean(currentStorageContent)\n  }\n\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n   */\n  async signOut(): Promise<{ error: AuthError | null }> {\n    const { data, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { error: sessionError }\n    }\n    const accessToken = data.session?.access_token\n    if (accessToken) {\n      const { error } = await this.admin.signOut(accessToken)\n      if (error) {\n        // ignore 404s since user might not exist anymore\n        // ignore 401s since an invalid or expired JWT should sign out the current session\n        if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n          return { error }\n        }\n      }\n    }\n    await this._removeSession()\n    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n    this._notifyAllSubscribers('SIGNED_OUT', null)\n    return { error: null }\n  }\n\n  /**\n   * Receive a notification every time an auth event happens.\n   * @param callback A callback function to be invoked when an auth event happens.\n   */\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\n    data: { subscription: Subscription }\n  } {\n    const id: string = uuid()\n    const subscription: Subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id)\n      },\n    }\n\n    this.stateChangeEmitters.set(id, subscription)\n\n    this.emitInitialSession(id)\n\n    return { data: { subscription } }\n  }\n\n  private async emitInitialSession(id: string): Promise<void> {\n    try {\n      const {\n        data: { session },\n        error,\n      } = await this.getSession()\n      if (error) throw error\n\n      this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', session)\n    } catch (err) {\n      this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', null)\n      console.error(err)\n    }\n  }\n\n  /**\n   * Sends a password reset request to an email address.\n   * @param email The email address of the user.\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<\n    | {\n        data: {}\n        error: null\n      }\n    | { data: null; error: AuthError }\n  > {\n    let codeChallenge: string | null = null\n    let codeChallengeMethod: string | null = null\n    if (this.flowType === 'pkce') {\n      const codeVerifier = generatePKCEVerifier()\n      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n      codeChallenge = await generatePKCEChallenge(codeVerifier)\n      codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n    }\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/recover`, {\n        body: {\n          email,\n          code_challenge: codeChallenge,\n          code_challenge_method: codeChallengeMethod,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  private async _refreshAccessToken(refreshToken: string): Promise<AuthResponse> {\n    try {\n      const startedAt = Date.now()\n\n      // will attempt to refresh the token with exponential backoff\n      return await retryable(\n        async (attempt) => {\n          await sleep(attempt * 200) // 0, 200, 400, 800, ...\n\n          return await _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n            body: { refresh_token: refreshToken },\n            headers: this.headers,\n            xform: _sessionResponse,\n          })\n        },\n        (attempt, _, result) =>\n          result &&\n          result.error &&\n          result.error instanceof AuthRetryableFetchError &&\n          // retryable only if the request can be sent before the backoff overflows the tick duration\n          Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION\n      )\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n      throw error\n    }\n  }\n\n  private _isValidSession(maybeSession: unknown): maybeSession is Session {\n    const isValidSession =\n      typeof maybeSession === 'object' &&\n      maybeSession !== null &&\n      'access_token' in maybeSession &&\n      'refresh_token' in maybeSession &&\n      'expires_at' in maybeSession\n\n    return isValidSession\n  }\n\n  private async _handleProviderSignIn(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n      skipBrowserRedirect?: boolean\n    }\n  ) {\n    const url: string = await this._getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams,\n    })\n    // try to open on the browser\n    if (isBrowser() && !options.skipBrowserRedirect) {\n      window.location.assign(url)\n    }\n\n    return { data: { provider, url }, error: null }\n  }\n\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  private async _recoverAndRefresh() {\n    try {\n      const currentSession = await getItemAsync(this.storage, this.storageKey)\n      if (!this._isValidSession(currentSession)) {\n        if (currentSession !== null) {\n          await this._removeSession()\n        }\n\n        return\n      }\n\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if ((currentSession.expires_at ?? Infinity) < timeNow + EXPIRY_MARGIN) {\n        if (this.autoRefreshToken && currentSession.refresh_token) {\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\n\n          if (error) {\n            console.log(error.message)\n            await this._removeSession()\n          }\n        } else {\n          await this._removeSession()\n        }\n      } else {\n        if (this.persistSession) {\n          await this._saveSession(currentSession)\n        }\n        this._notifyAllSubscribers('SIGNED_IN', currentSession)\n      }\n    } catch (err) {\n      console.error(err)\n      return\n    }\n  }\n\n  private async _callRefreshToken(refreshToken: string): Promise<CallRefreshTokenResult> {\n    // refreshing is already in progress\n    if (this.refreshingDeferred) {\n      return this.refreshingDeferred.promise\n    }\n\n    try {\n      this.refreshingDeferred = new Deferred<CallRefreshTokenResult>()\n\n      if (!refreshToken) {\n        throw new AuthSessionMissingError()\n      }\n      const { data, error } = await this._refreshAccessToken(refreshToken)\n      if (error) throw error\n      if (!data.session) throw new AuthSessionMissingError()\n\n      await this._saveSession(data.session)\n      this._notifyAllSubscribers('TOKEN_REFRESHED', data.session)\n\n      const result = { session: data.session, error: null }\n\n      this.refreshingDeferred.resolve(result)\n\n      return result\n    } catch (error) {\n      if (isAuthError(error)) {\n        const result = { session: null, error }\n\n        this.refreshingDeferred?.resolve(result)\n\n        return result\n      }\n\n      this.refreshingDeferred?.reject(error)\n      throw error\n    } finally {\n      this.refreshingDeferred = null\n    }\n  }\n\n  private _notifyAllSubscribers(event: AuthChangeEvent, session: Session | null, broadcast = true) {\n    if (this.broadcastChannel && broadcast) {\n      this.broadcastChannel.postMessage({ event, session })\n    }\n\n    this.stateChangeEmitters.forEach((x) => x.callback(event, session))\n  }\n\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  private async _saveSession(session: Session) {\n    if (!this.persistSession) {\n      this.inMemorySession = session\n    }\n\n    if (this.persistSession && session.expires_at) {\n      await this._persistSession(session)\n    }\n  }\n\n  private _persistSession(currentSession: Session) {\n    return setItemAsync(this.storage, this.storageKey, currentSession)\n  }\n\n  private async _removeSession() {\n    if (this.persistSession) {\n      await removeItemAsync(this.storage, this.storageKey)\n    } else {\n      this.inMemorySession = null\n    }\n  }\n\n  /**\n   * Removes any registered visibilitychange callback.\n   *\n   * {@see #startAutoRefresh}\n   * {@see #stopAutoRefresh}\n   */\n  private _removeVisibilityChangedCallback() {\n    const callback = this.visibilityChangedCallback\n    this.visibilityChangedCallback = null\n\n    try {\n      if (callback && isBrowser() && window?.removeEventListener) {\n        window.removeEventListener('visibilitychange', callback)\n      }\n    } catch (e) {\n      console.error('removing visibilitychange callback failed', e)\n    }\n  }\n\n  /**\n   * This is the private implementation of {@link #startAutoRefresh}. Use this\n   * within the library.\n   */\n  private async _startAutoRefresh() {\n    await this._stopAutoRefresh()\n\n    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION)\n    this.autoRefreshTicker = ticker\n\n    if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n      // ticker is a NodeJS Timeout object that has an `unref` method\n      // https://nodejs.org/api/timers.html#timeoutunref\n      // When auto refresh is used in NodeJS (like for testing) the\n      // `setInterval` is preventing the process from being marked as\n      // finished and tests run endlessly. This can be prevented by calling\n      // `unref()` on the returned object.\n      ticker.unref()\n      // @ts-ignore\n    } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {\n      // similar like for NodeJS, but with the Deno API\n      // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n      // @ts-ignore\n      Deno.unrefTimer(ticker)\n    }\n\n    // run the tick immediately\n    await this._autoRefreshTokenTick()\n  }\n\n  /**\n   * This is the private implementation of {@link #stopAutoRefresh}. Use this\n   * within the library.\n   */\n  private async _stopAutoRefresh() {\n    const ticker = this.autoRefreshTicker\n    this.autoRefreshTicker = null\n\n    if (ticker) {\n      clearInterval(ticker)\n    }\n  }\n\n  /**\n   * Starts an auto-refresh process in the background. The session is checked\n   * every few seconds. Close to the time of expiration a process is started to\n   * refresh the session. If refreshing fails it will be retried for as long as\n   * necessary.\n   *\n   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n   * to call this function, it will be called for you.\n   *\n   * On browsers the refresh process works only when the tab/window is in the\n   * foreground to conserve resources as well as prevent race conditions and\n   * flooding auth with requests. If you call this method any managed\n   * visibility change callback will be removed and you must manage visibility\n   * changes on your own.\n   *\n   * On non-browser platforms the refresh process works *continuously* in the\n   * background, which may not be desireable. You should hook into your\n   * platform's foreground indication mechanism and call these methods\n   * appropriately to conserve resources.\n   *\n   * {@see #stopAutoRefresh}\n   */\n  async startAutoRefresh() {\n    this._removeVisibilityChangedCallback()\n    await this._startAutoRefresh()\n  }\n\n  /**\n   * Stops an active auto refresh process running in the background (if any).\n   *\n   * If you call this method any managed visibility change callback will be\n   * removed and you must manage visibility changes on your own.\n   *\n   * See {@link #startAutoRefresh} for more details.\n   */\n  async stopAutoRefresh() {\n    this._removeVisibilityChangedCallback()\n    await this._stopAutoRefresh()\n  }\n\n  /**\n   * Runs the auto refresh token tick.\n   */\n  private async _autoRefreshTokenTick() {\n    const now = Date.now()\n\n    try {\n      const {\n        data: { session },\n      } = await this.getSession()\n\n      if (!session || !session.refresh_token || !session.expires_at) {\n        return\n      }\n\n      // session will expire in this many ticks (or has already expired if <= 0)\n      const expiresInTicks = Math.floor(\n        (session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION\n      )\n\n      if (expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD) {\n        await this._callRefreshToken(session.refresh_token)\n      }\n    } catch (e: any) {\n      console.error('Auto refresh tick failed with error. This is likely a transient error.', e)\n    }\n  }\n\n  /**\n   * Registers callbacks on the browser / platform, which in-turn run\n   * algorithms when the browser window/tab are in foreground. On non-browser\n   * platforms it assumes always foreground.\n   */\n  private async _handleVisibilityChange() {\n    if (!isBrowser() || !window?.addEventListener) {\n      if (this.autoRefreshToken) {\n        // in non-browser environments the refresh token ticker runs always\n        this.startAutoRefresh()\n      }\n\n      return false\n    }\n\n    try {\n      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false)\n\n      window?.addEventListener('visibilitychange', this.visibilityChangedCallback)\n\n      // now immediately call the visbility changed callback to setup with the\n      // current visbility state\n      await this._onVisibilityChanged(true) // initial call\n    } catch (error) {\n      console.error('_handleVisibilityChange', error)\n    }\n  }\n\n  /**\n   * Callback registered with `window.addEventListener('visibilitychange')`.\n   */\n  private async _onVisibilityChanged(isInitial: boolean) {\n    if (document.visibilityState === 'visible') {\n      if (!isInitial) {\n        // initial visibility change setup is handled in another flow under #initialize()\n        await this.initializePromise\n        await this._recoverAndRefresh()\n      }\n\n      if (this.autoRefreshToken) {\n        // in browser environments the refresh token ticker runs only on focused tabs\n        // which prevents race conditions\n        this._startAutoRefresh()\n      }\n    } else if (document.visibilityState === 'hidden') {\n      if (this.autoRefreshToken) {\n        this._stopAutoRefresh()\n      }\n    }\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n   */\n  private async _getUrlForProvider(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    if (this.flowType === 'pkce') {\n      const codeVerifier = generatePKCEVerifier()\n      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n      const codeChallenge = await generatePKCEChallenge(codeVerifier)\n      const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n      const flowParams = new URLSearchParams({\n        code_challenge: `${encodeURIComponent(codeChallenge)}`,\n        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`,\n      })\n      urlParams.push(flowParams.toString())\n    }\n    if (options?.queryParams) {\n      const query = new URLSearchParams(options.queryParams)\n      urlParams.push(query.toString())\n    }\n\n    return `${this.url}/authorize?${urlParams.join('&')}`\n  }\n\n  private async _unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      return await _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n        headers: this.headers,\n        jwt: sessionData?.session?.access_token,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#enroll}\n   */\n  private async _enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/factors`, {\n        body: {\n          friendly_name: params.friendlyName,\n          factor_type: params.factorType,\n          issuer: params.issuer,\n        },\n        headers: this.headers,\n        jwt: sessionData?.session?.access_token,\n      })\n\n      if (error) {\n        return { data: null, error }\n      }\n\n      if (data?.totp?.qr_code) {\n        data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`\n      }\n\n      return { data, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#verify}\n   */\n  private async _verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      const { data, error } = await _request(\n        this.fetch,\n        'POST',\n        `${this.url}/factors/${params.factorId}/verify`,\n        {\n          body: { code: params.code, challenge_id: params.challengeId },\n          headers: this.headers,\n          jwt: sessionData?.session?.access_token,\n        }\n      )\n      if (error) {\n        return { data: null, error }\n      }\n\n      await this._saveSession({\n        expires_at: Math.round(Date.now() / 1000) + data.expires_in,\n        ...data,\n      })\n      this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data)\n\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#challenge}\n   */\n  private async _challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      return await _request(\n        this.fetch,\n        'POST',\n        `${this.url}/factors/${params.factorId}/challenge`,\n        {\n          headers: this.headers,\n          jwt: sessionData?.session?.access_token,\n        }\n      )\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#challengeAndVerify}\n   */\n  private async _challengeAndVerify(\n    params: MFAChallengeAndVerifyParams\n  ): Promise<AuthMFAVerifyResponse> {\n    const { data: challengeData, error: challengeError } = await this._challenge({\n      factorId: params.factorId,\n    })\n    if (challengeError) {\n      return { data: null, error: challengeError }\n    }\n    return await this._verify({\n      factorId: params.factorId,\n      challengeId: challengeData.id,\n      code: params.code,\n    })\n  }\n\n  /**\n   * {@see GoTrueMFAApi#listFactors}\n   */\n  private async _listFactors(): Promise<AuthMFAListFactorsResponse> {\n    const {\n      data: { user },\n      error: userError,\n    } = await this.getUser()\n    if (userError) {\n      return { data: null, error: userError }\n    }\n\n    const factors = user?.factors || []\n    const totp = factors.filter(\n      (factor) => factor.factor_type === 'totp' && factor.status === 'verified'\n    )\n\n    return {\n      data: {\n        all: factors,\n        totp,\n      },\n      error: null,\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n   */\n  private async _getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse> {\n    const {\n      data: { session },\n      error: sessionError,\n    } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n    if (!session) {\n      return {\n        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n        error: null,\n      }\n    }\n\n    const payload = this._decodeJWT(session.access_token)\n\n    let currentLevel: AuthenticatorAssuranceLevels | null = null\n\n    if (payload.aal) {\n      currentLevel = payload.aal\n    }\n\n    let nextLevel: AuthenticatorAssuranceLevels | null = currentLevel\n\n    const verifiedFactors =\n      session.user.factors?.filter((factor: Factor) => factor.status === 'verified') ?? []\n\n    if (verifiedFactors.length > 0) {\n      nextLevel = 'aal2'\n    }\n\n    const currentAuthenticationMethods = payload.amr || []\n\n    return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}